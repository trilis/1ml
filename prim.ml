(*
 * (c) 2014 Andreas Rossberg
 *)

type typ =
  | BoolT
  | IntT
  | CharT
  | TextT
  | FloatT
  | VarT

type effect =
  | PureE
  | ImpureE

type const =
  | BoolV of bool
  | IntV of int
  | FloatV of float
  | CharV of char
  | TextV of string
  | FunV of func

and func =
  { name : string;
    typ : typ list * effect * typ list;
    fn : const list -> const list
  }

let typ_of_string = function
  | "bool" -> Some BoolT
  | "int" -> Some IntT
  | "char" -> Some CharT
  | "text" -> Some TextT
  | "float" -> Some FloatT
  | _ -> None

let string_of_typ = function
  | BoolT -> "bool"
  | IntT -> "int"
  | CharT -> "char"
  | TextT -> "text"
  | FloatT -> "float"
  | VarT -> assert false

let typ_of_const = function
  | BoolV _ -> BoolT
  | IntV _ -> IntT
  | CharV _ -> CharT
  | TextV _ -> TextT
  | FloatV _ -> FloatT
  | FunV _ -> assert false

let string_of_const = function
  | BoolV(b) -> string_of_bool b
  | IntV(i) -> string_of_int i
  | CharV(c) -> "'" ^ Char.escaped c ^ "'"
  | TextV(t) -> "\"" ^ String.escaped t ^ "\""
  | FunV(f) -> "(prim " ^ f.name ^ ")"
  | FloatV(f) -> string_of_float f

let is_poly {typ = ts1, _, ts2} = List.mem VarT ts1 || List.mem VarT ts2

let typs = [BoolT; IntT; CharT; TextT]

type 'a def =
  | VoidD: unit def
  | BoolD: bool def
  | IntD: int def
  | CharD: char def
  | TextD: string def
  | FloatD: float def
  | VarD: const def
  | ProdD: 'a def * 'b def -> ('a * 'b) def

let (&) l r = ProdD (l, r)

let rec typs_of: type a. a def -> typ list = function
  | VoidD -> []
  | BoolD -> [BoolT]
  | IntD -> [IntT]
  | CharD -> [CharT]
  | TextD -> [TextT]
  | FloatD -> [FloatT]
  | VarD -> [VarT]
  | ProdD (l, r) -> typs_of l @ typs_of r

let rec inj: type a. a def -> a -> const list -> const list = function
  | VoidD -> fun () vs -> vs
  | BoolD -> fun v vs -> BoolV v :: vs
  | IntD -> fun v vs -> IntV v :: vs
  | CharD -> fun v vs -> CharV v :: vs
  | FloatD -> fun v vs -> FloatV v :: vs
  | TextD -> fun v vs -> TextV v :: vs
  | VarD -> fun v vs -> v :: vs
  | ProdD (lD, rD) ->
    let injL = inj lD and injR = inj rD in fun (l, r) vs -> injL l (injR r vs)

let rec prj: type a. a def -> const list -> a * const list = function
  | VoidD -> fun vs -> ((), vs)
  | BoolD -> (function (BoolV v :: vs) -> (v, vs) | _ -> failwith "bool")
  | IntD -> (function (IntV v :: vs) -> (v, vs) | _ -> failwith "int")
  | CharD -> (function (CharV v :: vs) -> (v, vs) | _ -> failwith "char")
  | TextD -> (function (TextV v :: vs) -> (v, vs) | _ -> failwith "text")
  | FloatD -> (function (FloatV v :: vs) -> (v, vs) | _ -> failwith "float")
  | VarD -> (function (v :: vs) -> (v, vs) | _ -> failwith "var")
  | ProdD (lD, rD) ->
    let prjL = prj lD and prjR = prj rD in
    fun vs -> let (l, vs) = prjL vs in let (r, vs) = prjR vs in ((l, r), vs)

let def name inD effect outD fn = {
    name = name;
    typ = typs_of inD, effect, typs_of outD;
    fn = let inj = inj outD and prj = prj inD in
         fun vs -> let (v, vs) = prj vs in assert (vs = []); inj (fn v) []
  }

let funs =
  [
    def "==" (VarD & VarD) PureE BoolD (fun (x1, x2) -> x1 = x2);
    def "<>" (VarD & VarD) PureE BoolD (fun (x1, x2) -> x1 <> x2);

    def "true" VoidD PureE BoolD (fun () -> true);
    def "false" VoidD PureE BoolD (fun () -> false);

    def "Int.+" (IntD & IntD) PureE IntD (fun (i1, i2) -> i1 + i2);
    def "Int.-" (IntD & IntD) PureE IntD (fun (i1, i2) -> i1 - i2);
    def "Int.*" (IntD & IntD) PureE IntD (fun (i1, i2) -> i1 * i2);
    def "Int./" (IntD & IntD) PureE IntD (fun (i1, i2) -> i1 / i2);
    def "Int.%" (IntD & IntD) PureE IntD (fun (i1, i2) -> i1 mod i2);

    def "Int.<" (IntD & IntD) PureE BoolD (fun (i1, i2) -> i1 < i2);
    def "Int.>" (IntD & IntD) PureE BoolD (fun (i1, i2) -> i1 > i2);
    def "Int.<=" (IntD & IntD) PureE BoolD (fun (i1, i2) -> i1 <= i2);
    def "Int.>=" (IntD & IntD) PureE BoolD (fun (i1, i2) -> i1 >= i2);

    def "Int.toText" IntD PureE TextD string_of_int;
    def "Int.print" IntD ImpureE VoidD (fun i -> print_int i; flush_all ());

    def "Char.toInt" CharD PureE IntD Char.code;
    def "Char.fromInt" IntD PureE CharD Char.chr;

    def "Char.print" CharD ImpureE VoidD (fun c -> print_char c; flush_all ());

    def "Text.++" (TextD & TextD) PureE TextD (fun (t1, t2) -> t1 ^ t2);

    def "Text.<" (TextD & TextD) PureE BoolD (fun (i1, i2) -> i1 < i2);
    def "Text.>" (TextD & TextD) PureE BoolD (fun (i1, i2) -> i1 > i2);
    def "Text.<=" (TextD & TextD) PureE BoolD (fun (i1, i2) -> i1 <= i2);
    def "Text.>=" (TextD & TextD) PureE BoolD (fun (i1, i2) -> i1 >= i2);
    def "Text.==" (TextD & TextD) PureE BoolD (fun (i1, i2) -> i1 == i2);

    def "Text.length" TextD PureE IntD String.length;
    def "Text.sub" (TextD & IntD) PureE CharD (fun (t, i) -> t.[i]);
    def "Text.fromChar" CharD PureE TextD (String.make 1);

    def "Text.print" TextD ImpureE VoidD (fun t -> print_string t; flush_all ());

    def "Float.sqrt" FloatD PureE FloatD sqrt;
    def "Float.+" (FloatD & FloatD) PureE FloatD (fun (i1, i2) -> i1 +. i2);
    def "Float.-" (FloatD & FloatD) PureE FloatD (fun (i1, i2) -> i1 -. i2);
    def "Float./" (FloatD & FloatD) PureE FloatD (fun (i1, i2) -> i1 /. i2);
    def "Float.*" (FloatD & FloatD) PureE FloatD (fun (i1, i2) -> i1 *. i2);
    def "Float.print" FloatD ImpureE VoidD (fun i -> print_float i; flush_all ());

    def "System.exit" IntD ImpureE VarD exit;
  ]

let fun_of_string name =
  try Some (List.find (fun f -> name = f.name) funs) with Not_found -> None
